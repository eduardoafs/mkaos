// automatically generated by Xtext
grammar mkaos.Language with org.eclipse.xtext.common.Terminals

import "platform:/resource/Kaos/model/mkaos.ecore" 
import "platform:/resource/Kaos/model/kaos.ecore" as KAOSModel
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

mKAOS returns mKAOS:
	'Model'	name=EString
	(linkedBy+=Link 
	| consistsOf+=Nodes)* 
;

Link returns KAOSModel::Link:
	AssignmentLink | ConflictLink | ObstructionLink | OutputLink | InputLink | Refinement_Impl | AndRefinement | OrRefinement | OperacionalizationLink | ResolutionLink | ResponsabilityLink;

Nodes returns KAOSModel::Nodes:
	Mission | Operation | OperationNode_Impl | Event | Entity | Associations | SoftwareAgent | EnvironmentAgent | Obstacle | Goal_Impl | Expectation | DomainProperty_Impl | Requirement | DomainHypothesis | DomainInvariant;

Agent returns KAOSModel::Agent:
	SoftwareAgent | EnvironmentAgent;

Mission returns Mission:
	'Mission' name=EString '{'
	(links+=MissionLink (',' links+=MissionLink)*)?
	& ('resolves' resolve+=[KAOSModel::Obstacle|EString]
	| 'conflicts' conflicts+=[KAOSModel::Goal|EString]
	| 'concerns' concerns+=[KAOSModel::Object|EString])*
	& ('assigned' 'to' assignedTo=[ConstituentSystem|EString])?
	& ('priority' '=' priority=INT
	& 'description' '=' description=STRING
	& 'trigger' '=' trigger=expr
	& 'rule' '=' rule=expr)
	(refinement=MissionRefinement)?
	'}'
;

RefinableNode returns KAOSModel::RefinableNode:
	Mission | Obstacle | Goal_Impl | Expectation | DomainProperty_Impl | Requirement | DomainHypothesis | DomainInvariant;

MissionLink returns MissionLink:
	DisruptLink | SupportLink | BlockLink  
;

DisruptLink returns DisruptLink:
	'disrupt' target=[Mission|EString]
;

SupportLink returns SuportLink:
	'support' target=[Mission|EString]
;

BlockLink returns BlockLink:
	'block' target=[Mission|EString]
;

MissionRefinement returns MissionRefinement:
	'refinement' '[' (kind=MissionRefinementKind | custom=expr ) ']'
	'{'
		submissions+=Mission*
	'}'
;

enum MissionRefinementKind:
	all='all' | atLeastOne='atLestOne' | alternative='alternative' | custom='custom'
; 

Refinement returns KAOSModel::Refinement:
	Refinement_Impl | AndRefinement | OrRefinement | MissionRefinement;

Goal returns KAOSModel::Goal:
	Goal_Impl | Expectation | DomainProperty_Impl | Requirement | DomainHypothesis | DomainInvariant;

Object returns KAOSModel::Object:
	Entity | Associations | SoftwareAgent | EnvironmentAgent;


EString returns ecore::EString:
	STRING | ID;

AssignmentLink returns KAOSModel::AssignmentLink:
	'assignment' assignsGoalTo+=[KAOSModel::Agent|EString] (',' assignsGoalTo+=[KAOSModel::Agent|EString])*;
	//name=EString
	//'{'
	//	'assignsGoalTo' '(' assignsGoalTo+=[KAOSModel::Agent|EString] ( "," assignsGoalTo+=[KAOSModel::Agent|EString])* ')' 
	//'}';

ConflictLink returns KAOSModel::ConflictLink:
	{KAOSModel::ConflictLink}
	'ConflictLink'
	name=EString;

ObstructionLink returns KAOSModel::ObstructionLink:
	'ObstructionLink'
	name=EString
	'{'
		'relateKGoalTo' '(' relateKGoalTo+=[KAOSModel::Obstacle|EString] ( "," relateKGoalTo+=[KAOSModel::Obstacle|EString])* ')' 
	'}';

OutputLink returns KAOSModel::OutputLink:
	{KAOSModel::OutputLink}
	'OutputLink'
	name=EString;

InputLink returns KAOSModel::InputLink:
	'InputLink'
	name=EString
	'{'
		'objectInputOn' '(' objectInputOn+=[KAOSModel::Operation|EString] ( "," objectInputOn+=[KAOSModel::Operation|EString])* ')' 
	'}';

Refinement_Impl returns KAOSModel::Refinement:
	'refinement' 
	//name=EString
	'{'
		'refines' refines=[KAOSModel::RefinableNode|EString]
	'}';

AndRefinement returns KAOSModel::AndRefinement:
	'AndRefinement'
	name=EString
	'{'
		'refines' refines=[KAOSModel::RefinableNode|EString]
	'}';

OrRefinement returns KAOSModel::OrRefinement:
	'OrRefinement'
	name=EString
	'{'
		'refines' refines=[KAOSModel::RefinableNode|EString]
	'}';

OperacionalizationLink returns KAOSModel::OperacionalizationLink:
	'OperacionalizationLink'
	name=EString
	'{'
		'relateOperationTo' '(' relateOperationTo+=[KAOSModel::Requirement|EString] ( "," relateOperationTo+=[KAOSModel::Requirement|EString])* ')' 
	'}';

ResolutionLink returns KAOSModel::ResolutionLink:
	'ResolutionLink'
	name=EString
	'{'
		'assignObstacleTo' '(' assignObstacleTo+=[KAOSModel::Requirement|EString] ( "," assignObstacleTo+=[KAOSModel::Requirement|EString])* ')' 
	'}';

ResponsabilityLink returns KAOSModel::ResponsabilityLink:
	'ResponsabilityLink'
	name=EString
	'{'
		'assignAgentTo' '(' assignAgentTo+=[KAOSModel::Requirement|EString] ( "," assignAgentTo+=[KAOSModel::Requirement|EString])* ')' 
	'}';

Operation returns KAOSModel::Operation:
	'Operation' name=EString
	'{'
		'produces' '(' produces+=[KAOSModel::Event|EString] ( "," produces+=[KAOSModel::Event|EString])* ')' 
		'output' '(' output+=[KAOSModel::Entity|EString] ( "," output+=[KAOSModel::Entity|EString])* ')' 
		'operationalize' '(' operationalize+=[KAOSModel::Requirement|EString] ( "," operationalize+=[KAOSModel::Requirement|EString])* ')' 
	'}';

SoftwareAgent returns KAOSModel::SoftwareAgent:
	'SoftwareAgent'
	name=EString
	'{'
		'performs' '(' performs+=[KAOSModel::Operation|EString] ( "," performs+=[KAOSModel::Operation|EString])* ')' 
		('composition' '(' composition+=[KAOSModel::Agent|EString] ( "," composition+=[KAOSModel::Agent|EString])* ')' )?
		'responsibleFor' '(' responsibleFor+=[KAOSModel::Requirement|EString] ( "," responsibleFor+=[KAOSModel::Requirement|EString])* ')' 
	'}';

EnvironmentAgent returns KAOSModel::EnvironmentAgent:
	'EnvironmentAgent'
	name=EString
	'{'
		('performs' performs+=[KAOSModel::Operation|EString] ( "," performs+=[KAOSModel::Operation|EString])*)? 
		('composition' composition+=[KAOSModel::Agent|EString] ( "," composition+=[KAOSModel::Agent|EString])*)?
	'}';

Event returns KAOSModel::Event:
	{KAOSModel::Event}
	'Event' name=EString;

Entity returns KAOSModel::Entity:
	'Entity' name=EString
	('{'
		'composition' '=' composition+=[KAOSModel::Entity|EString] ( "," composition+=[KAOSModel::Entity|EString])*
	'}')?;

Requirement returns KAOSModel::Requirement:
	'Requirement'
	name=EString
	'{'
		'refinedBy' '(' refinedBy+=[KAOSModel::Refinement|EString] ( "," refinedBy+=[KAOSModel::Refinement|EString])* ')' 
		'resolve' '(' resolve+=[KAOSModel::Obstacle|EString] ( "," resolve+=[KAOSModel::Obstacle|EString])* ')' 
		'conflicts' '(' conflicts+=[KAOSModel::Goal|EString] ( "," conflicts+=[KAOSModel::Goal|EString])* ')' 
		'concerns' '(' concerns+=[KAOSModel::Object|EString] ( "," concerns+=[KAOSModel::Object|EString])* ')' 
	'}';

Obstacle returns KAOSModel::Obstacle:
	'Obstacle'
	name=EString
	'{'
		'refinedBy' '(' refinedBy+=[KAOSModel::Refinement|EString] ( "," refinedBy+=[KAOSModel::Refinement|EString])* ')' 
		'obstruct' '(' obstruct+=[KAOSModel::Goal|EString] ( "," obstruct+=[KAOSModel::Goal|EString])* ')' 
	'}';

Goal_Impl returns KAOSModel::Goal:
	'Goal'
	name=EString
	'{'
		'refinedBy' '(' refinedBy+=[KAOSModel::Refinement|EString] ( "," refinedBy+=[KAOSModel::Refinement|EString])* ')' 
		'resolve' '(' resolve+=[KAOSModel::Obstacle|EString] ( "," resolve+=[KAOSModel::Obstacle|EString])* ')' 
		'conflicts' '(' conflicts+=[KAOSModel::Goal|EString] ( "," conflicts+=[KAOSModel::Goal|EString])* ')' 
		'concerns' '(' concerns+=[KAOSModel::Object|EString] ( "," concerns+=[KAOSModel::Object|EString])* ')' 
	'}';

Expectation returns KAOSModel::Expectation:
	'Expectation'
	name=EString
	'{'
		'refinedBy' '(' refinedBy+=[KAOSModel::Refinement|EString] ( "," refinedBy+=[KAOSModel::Refinement|EString])* ')' 
		'resolve' '(' resolve+=[KAOSModel::Obstacle|EString] ( "," resolve+=[KAOSModel::Obstacle|EString])* ')' 
		'conflicts' '(' conflicts+=[KAOSModel::Goal|EString] ( "," conflicts+=[KAOSModel::Goal|EString])* ')' 
		'concerns' '(' concerns+=[KAOSModel::Object|EString] ( "," concerns+=[KAOSModel::Object|EString])* ')' 
		'assignedTo' '(' assignedTo+=[KAOSModel::EnvironmentAgent|EString] ( "," assignedTo+=[KAOSModel::EnvironmentAgent|EString])* ')' 
	'}';

DomainProperty_Impl returns KAOSModel::DomainProperty:
	'DomainProperty'
	name=EString
	'{'
		'refinedBy' '(' refinedBy+=[KAOSModel::Refinement|EString] ( "," refinedBy+=[KAOSModel::Refinement|EString])* ')' 
		'resolve' '(' resolve+=[KAOSModel::Obstacle|EString] ( "," resolve+=[KAOSModel::Obstacle|EString])* ')' 
		'conflicts' '(' conflicts+=[KAOSModel::Goal|EString] ( "," conflicts+=[KAOSModel::Goal|EString])* ')' 
		'concerns' '(' concerns+=[KAOSModel::Object|EString] ( "," concerns+=[KAOSModel::Object|EString])* ')' 
		'usedIn' '(' usedIn+=[KAOSModel::Refinement|EString] ( "," usedIn+=[KAOSModel::Refinement|EString])* ')' 
	'}';

DomainHypothesis returns KAOSModel::DomainHypothesis:
	'DomainHypothesis'
	name=EString
	'{'
		'refinedBy' '(' refinedBy+=[KAOSModel::Refinement|EString] ( "," refinedBy+=[KAOSModel::Refinement|EString])* ')' 
		'resolve' '(' resolve+=[KAOSModel::Obstacle|EString] ( "," resolve+=[KAOSModel::Obstacle|EString])* ')' 
		'conflicts' '(' conflicts+=[KAOSModel::Goal|EString] ( "," conflicts+=[KAOSModel::Goal|EString])* ')' 
		'concerns' '(' concerns+=[KAOSModel::Object|EString] ( "," concerns+=[KAOSModel::Object|EString])* ')' 
		'usedIn' '(' usedIn+=[KAOSModel::Refinement|EString] ( "," usedIn+=[KAOSModel::Refinement|EString])* ')' 
	'}';

DomainInvariant returns KAOSModel::DomainInvariant:
	'DomainInvariant'
	name=EString
	'{'
		'refinedBy' '(' refinedBy+=[KAOSModel::Refinement|EString] ( "," refinedBy+=[KAOSModel::Refinement|EString])* ')' 
		'resolve' '(' resolve+=[KAOSModel::Obstacle|EString] ( "," resolve+=[KAOSModel::Obstacle|EString])* ')' 
		'conflicts' '(' conflicts+=[KAOSModel::Goal|EString] ( "," conflicts+=[KAOSModel::Goal|EString])* ')' 
		'concerns' '(' concerns+=[KAOSModel::Object|EString] ( "," concerns+=[KAOSModel::Object|EString])* ')' 
		'usedIn' '(' usedIn+=[KAOSModel::Refinement|EString] ( "," usedIn+=[KAOSModel::Refinement|EString])* ')' 
	'}';

Associations returns KAOSModel::Associations:
	{KAOSModel::Associations}
	'Associations'
	name=EString;

OperationNode_Impl returns KAOSModel::OperationNode:
	{KAOSModel::OperationNode}
	'OperationNode'
	name=EString;

ConstituentSystem returns ConstituentSystem:
	'System' name=EString
	'capableOf' capableOf+=[OperationalCapability|EString] (',' capableOf+=[OperationalCapability|EString])*
;

OperationalCapability returns OperationalCapability:
	'OperationalCapability' name=EString '{'
		'in' input+=[KAOSModel::Entity|EString]
		'out' output+=[KAOSModel::Entity|EString]
		('description' '=' desc=STRING)? 
	'}'
;

CommunicationalCapability returns CommunicationalCapability:
	'CommunicationalCapability' name=EString '{'
		'in' input+=[KAOSModel::Entity|EString]
		'out' output+=[KAOSModel::Entity|EString]
		('description' '=' desc=STRING)? 
	'}'
;


// All DynBLTL constructs, we don't need to store properly, just sintax checking

expr returns DynBLTL: // returns [Expr val]:
  q=RuleQuantifier val=ID COL c=function t=temporal    //{ val = new QuantExpr($q.q,new Var($ID.text),$c.val,$e.val); } 
| temporal                                     //{ val = $temporal.val ; }
;

enum RuleQuantifier: // returns [UnOp q]:
  EXISTS='exists'  //{ q = UnOp.Exists ; }
| FORALL='forall'  //{ q = UnOp.Forall ; }
| COUNT='count'  //{ q = UnOp.Count ; }
;

temporal returns RuleTemporal:// returns [Expr val]:
  val1=implication                   //{val = $implication.val ; }
  ( o=RuleTempBinOp  b=bound e=expr   //{ val =  new TemporalBinOpExpr(val,$tempbinop.o,$expr.val,$bound.b); }
  )? 
 | o1=RuleTempUnOp  b=bound e=expr     //{ val = new TemporalUnOpExpr($tempunop.o,$expr.val,$bound.b); }
;


bound returns RuleBound:// ; returns [Bound b]// @init{ Expr boundVal = new UndefValue();}:
( integerlit=INT                  //{ boundVal = new IntValue($integerlit.val) ;  }
| floatlit=FLOAT                   //{ boundVal = new FloatValue($floatlit.val) ;  }  
| LP e=expr RP                  //{ boundVal = $expr.val; }
) ( STEPS                     //{ b = new Bound(boundVal,false); }
| T_UNITS                     //{ b = new Bound(boundVal,true) ; }
)
;


enum RuleTempBinOp: // returns [BinOp o]:
      UNTIL='until'             //{ o = BinOp.Until ; }
    | WEAK='weak until'             //{ o = BinOp.Weak ; } // FIXME remove _
;


enum RuleTempUnOp: // returns [UnOp o]:
  FATALLY='eventually before'    //{ o = UnOp.Fatally ; }
| GLOBALLY='always during'   //{ o = UnOp.Globally ; }
| NEXT='in'       //{ o = UnOp.Next ; }
;

implication returns RuleImplication: // returns [Expr val]       @init{ UnOp undefOp = null; }
 (undefop                                //{ undefOp = $undefop.val ; }
  )? l=disjunction                        //{ val = $l.val; }
                (IMP r+=disjunction        //{ val = new BinOpExpr(val, BinOp.Imp, $r.val);  }
                                   )*     //{ if(undefOp != null) { val = new UnOpExpr(undefOp,val) ; } } 
;

undefop: // returns[UnOp val]:
  ISTRUE                 //{ val = UnOp.IsTrue; }
| ISNFLS                 //{ val = UnOp.IsNotFalse ; }
;

disjunction returns RuleDisjunction: // returns [Expr val]
 l=conjunction                          // { val = $l.val; } 
                (OR r+=conjunction        // { val = new BinOpExpr(val, BinOp.Or, $r.val);  }
                                  )*
;
 
conjunction returns RuleConjunction: // returns [Expr val]: 
  l=equality                              //{ val = $l.val; }
             ( AND r+=equality             //{ val = new BinOpExpr(val, BinOp.And, $r.val);  }
                               )*
;

equality returns RuleEquality: //returns [Expr val]          @init{ boolean neg = false; }
 (neg?=NOT                                    //{ neg = true ; }
      )? l=relExp                         //{ val = $l.val; }
                  (eop r=relExp           //{ val = new BinOpExpr($l.val, $eop.val, $r.val);  }
                                )?        //{ if(neg) {val = new UnOpExpr(UnOp.Not, val);  } }
;

eop: //returns [BinOp val]
 EQ                                      //{ val = BinOp.Eq; }
| NEQ                                     //{ val = BinOp.Neq; }
;

relExp returns RuleRelExp: // returns [Expr val]:
  l=numExp                     //{ val = $l.val; }  
           (rop r=numExp       //{ val = new BinOpExpr(val, $rop.val, $r.val);  }
                        )?
;

rop //returns [BinOp val]
: GT                       //{ val = BinOp.Gt; }
| LT                       //{ val = BinOp.Lt; }
| GE                       //{ val = BinOp.Ge; }
| LE                       //{ val = BinOp.Le; }
;

numExp returns RuleNumExp: //returns [Expr val]:
  l=term                       //{ val = $l.val; }    
         (addop r+=term         //{ val = new BinOpExpr(val, $addop.val, $r.val);  }
                    )*
;

addop: //returns [BinOp val]:
  ADD                          //{ val = BinOp.Add;  }
| MIN                          //{ val = BinOp.Min;  }
;

term returns RuleTerm: //returns [Expr val]:
  l=factor                     //{ val = $l.val; }
           (mulop r+=factor     //{ val = new BinOpExpr(val, $mulop.val, $r.val); }
                        )*
;

mulop: // returns [BinOp val]: 
  MUL                      //{ val = BinOp.Mul; }
| DIV                      //{ val = BinOp.Div; }
;

factor returns RuleFactor: // returns [Expr val]  @init{ boolean neg = false; }
 MIN?
  ( vallit=literal              // { val = $literal.val ;}
   | valvar=var                   //{ val = $var.val     ;}
   | valfun=function              //{ val = $function.val;}
   | LP par=expr RP        //{ val = $par.val; }
   | LC curl=expr RC       //{ val = $curl.val; }
   )                       //{ if(neg) { val = new UnOpExpr(UnOp.Neg,val); }  }
;

var returns RuleVar: // returns [Var val]:
 val+=ID                        //{ val = new Var($ID.text); } 
| val+=ID DOT val+=ID            //{ ArrayList<Expr> index = new ArrayList<Expr>(); }
   ('[' i+=numExp ']'       //{ index.add(i);}
   )*                      //{ val = new ConnectionVar($c.text, new Var($n.text),index);  }
;

//function returns [FuncExpr val]:
//  FUNC_ALLTYPE LP ALPHA RP                { val = new FuncAllType($ALPHA.text) ; }
//| FUNC_ARELINK LP c1=var COMMA c2=var RP  { val = new FuncAreLinked($c1.val,$c2.val) ;}
//| FUNC_ARECONN LP n1=var COMMA n2=var RP  { val = new FuncAreConnected($n1.val,$n2.val) ;}
//;

// TODO add default functions here
function returns RuleFunction: // returns [FuncExpr val]:
  ID LP l=params RP // { val = FuncExpr.createFunction($ID.text,$params.l) ;  }
;

params returns RuleParams: //returns [List<Expr> l]:
  l+=var        //{ l= new ArrayList<Expr>() ; l.add($v1.val); }
 ( COMMA l+=var //{ l.add($v2.val) ; }
 )*
;


literal returns RuleLiteral:// returns [Value val]: 
  floatlit                     //{ val = new FloatValue(f);   }
| integerlit                   //{ val = new IntValue(i);       }
| stringlit                    //{ val = new StringValue(s); }
| booleanlit                   //{ val = new BooleanValue(b);  }
| tuplelit                     //{ val = t; }
| seqlit                       //{ val = l; }
| nodelit                      //{ val = new NodeValue(n); }
;

integerlit returns RuleIntegerLit: //returns [int val]:
  val=INT             //{ val = Integer.parseInt($DIGITS.text); }
;

floatlit returns RuleFloatLit:
	val=FLOAT
;

terminal FLOAT returns ecore::EFloat:
	('-')? INT '.' INT
;

stringlit: // returns [String val]:
  STRING                        //{ val=$STRING.text ; }         
;

nodelit: // returns [String val]:
  'node<' ID '>'        //{ val = $name.text ; }
;    

booleanlit: // returns [boolean val]:
  TRUE                       //{ val = true; }
| FALSE                      //{ val = false; }
; 

tuplelit returns RuleTupleLit: //returns [TupleValue val]  @init{ ArrayList<Value> vals = new ArrayList<Value>();}
  'tuple<' vals+=literal                   //{ vals.add(m);}
      ( ',' vals+=literal                   //{ vals.add(m);}
      )+ 
   '>'                            //{ val = new TupleValue(vals); }
;

seqlit returns RuleSeqLit: //returns [SequenceValue val]  @init{ ArrayList<Value> vals = new ArrayList<Value>();}
  'seq<' vals+=literal                      //{ vals.add(m);}
      ( ',' vals+=literal                    //{ vals.add(m);}
      )+ 
   '>'                                   //{ val = new SequenceValue(vals); }
;

// ****************************************************************************
// *                                                                          *
// *                                   TOKENS                                 *
// *                                                                          *
// ****************************************************************************

//MODALITIES
STEPS: 'steps' ;
T_UNITS: 'time' 'units' ;

// ATOMS
FALSE : 'false';
TRUE : 'true';

// ARITH
ADD: '+';
MIN: '-';
MUL: '*';
DIV: '/';

// BOOL
NOT: 'not';
AND: 'and';
OR: 'or';
IMP: 'implies';

// 3 valued to 2 valued logic
ISTRUE: 'isTrue';
ISNFLS: 'isNotFalse';

// COMPARISONS 
EQ: '=';
NEQ: '!=';
LT: '<';
LE: '<=';
GE: '>=';
GT: '>';


// OTHER SYMBOLS
LP: '(';
RP: ')';
LB: '[';
RB: ']';
LC: '{';
RC: '}';
//SH: '#';
COL:':';
SEMI:';';
COMMA:',';
DQ: '"';
COLEQ: ':=';
DOT: '.';
